# 基于 FNO 的轴承钢感应淬火模拟 - 模型指导手册 (v1.0)

**文档位置**: `docs/model_guide.md`  
**最后更新**: 2025-12-15\
**维护人**: 华浩宇

👋 大家好！

这是为了推进我们的“轴承钢感应淬火模拟”项目而编写的技术指南。为了确保大家在开发过程中步调一致，少走弯路，请务必仔细阅读以下内容。我们重点解决“为什么选 FNO”、“数据怎么存”以及“遇到震荡怎么调”这三个核心问题。

---

## 1. 项目背景与模型架构演进

在本次项目中，我们最初选择了 **Fourier Neural Operator (FNO)** 作为基础架构，利用其全局感受野处理热传导问题。

然而，单纯的 FNO 在处理**相变边界（Hardening Case）**这种高频突变特征时表现欠佳。为了同时捕捉全局热扩散趋势和局部的相变尖锐边界，我们升级到了 **Parallel U-FNO (双流架构)**。

### 为什么选择 Parallel U-FNO？

* **FNO 的优势 (全局)**：
    基于傅里叶变换，在频域操作，每一层都天然拥有全局视野，非常适合捕捉整体的温度分布和热扩散趋势。

* **U-Net 的优势 (局部)**：
    经典的 U-Net 结构擅长图像分割和边缘检测，能够很好地捕捉局部的几何特征和尖锐的相变边界。

* **双流融合**：
    Parallel U-FNO 将两者并行，分别提取全局和局部特征，最后融合输出。这解决了单一 FNO 在高频细节（如淬火硬化层边界）上模糊的问题。

---

## 2. 核心原理：Parallel U-FNO & 损失函数创新

### 2.1 架构融合 —— "Parallel U-FNO" (双流架构)

我们的模型不再是一个简单的 FNO，而是一个双流并行网络：

1. **Stream 1: FNO Path (全局流)**
    * 负责捕捉低频、全局的物理场信息（如整体温度梯度）。
    * 利用 FFT 在频域进行卷积，具有分辨率无关性。

2. **Stream 2: U-Net Path (局部流)**
    * 负责捕捉高频、局部的细节信息（特别是相变层的尖锐边界）。
    * 利用标准卷积和跳跃连接（Skip Connections）保留空间细节。

3. **Fusion (融合)**
    * 两个流的输出在特征维度进行拼接或加权求和，通过一个解码器（Decoder）得到最终预测。

### 2.2 损失函数创新 —— Sobel Gradient Loss

在早期的实验中，我发现通用的 **MSE Loss** (均方误差) 虽然能让预测值在数值上接近真实值，但会导致**相变边界变模糊**。这是因为 MSE 对边缘的高频误差不敏感。

为了解决这个问题，我们引入了 **Sobel 梯度损失**：

1. **Sobel 算子**：
    定义水平 ($G_x$) 和垂直 ($G_y$) 方向的 Sobel 卷积核，用于计算物理场的空间梯度（即变化率）。

2. **梯度损失计算**：
    $$ Loss_{grad} = || \nabla \hat{y} - \nabla y ||^2 = || Sobel(\hat{y}) - Sobel(y) ||^2 $$
    其中 $\hat{y}$ 是预测值，$y$ 是真实值。

3. **总损失函数**：
    $$ Loss_{total} = Loss_{MSE} + \lambda \cdot Loss_{grad} $$
    通过加入梯度损失，强迫模型不仅数值要准，**形状和边界也要准**。这对于预测硬化层深度至关重要。

---

## 3. 物理直觉 (FNO 部分)

为了方便理解 FNO 部分（全局流）的原理：

1. **类比格林函数 (Green's Function)**：
    求解偏微分方程（PDE）时，如果我们找到了格林函数 $G(x, y)$，就可以通过积分 $\int G(x, y)f(y) dy$ 算出结果。FNO 本质上就是通过数据去**学习这个积分算子（Integral Operator）**。

2. **流程图解**：
    FNO 的核心计算发生在“频域”：
    * **Step 1: 空间域 -> 频域**：对输入（如初始温度场）做 FFT（快速傅里叶变换）。
    * **Step 2: 线性变换**：在频域中，偏微分操作往往变成了简单的乘法。网络在这里学习一个权重矩阵 $R$，只保留低频分量（主要的物理特征），过滤掉高频噪声。
    * **Step 3: 频域 -> 空间域**：做 IFFT（傅里叶逆变换）回到物理空间。
    * **Step 4: 非线性激活**：加上激活函数（如 GELU），拟合非线性关系。

> **一句话总结**：我们在频域里做低通滤波和特征提取，比在空间域硬算差分要高效得多。

---

## 4. 数据格式规范 (CRITICAL ⚠️)

> **重要更新**: 为了适配 PyTorch 的卷积操作习惯，我们最终采用了 **Channel First** 格式存储和训练。

所有预处理后的 `.npy` 文件以及模型输入输出张量，均遵循以下格式：

**Shape**: `[Batch, Channels, Height, Width]`

| 维度索引 | 维度名称 | 说明 | 示例值 |
| :--- | :--- | :--- | :--- |
| **Dim 0** | **Batch** | 时间步 (Time Steps) 或 样本数 | `N` (如 100) |
| **Dim 1** | **Channels** | 物理量通道 | `4` (见下表) |
| **Dim 2** | **Height** | 空间网格 Z 轴 (轴向) | `128` |
| **Dim 3** | **Width** | 空间网格 R 轴 (径向) | `64` |

### 通道定义 (Channels)

输入与目标数据的通道定义如下（由 `preprocessor.py` 生成）：

| 通道索引 | 物理含义 | 说明 |
| :--- | :--- | :--- |
| **0** | **Temperature (Norm)** | 归一化后的温度场 (0~1) |
| **1** | **Austenite** | 奥氏体相分数 (0~1) |
| **2** | **Martensite** | 马氏体相分数 (0~1) |
| **3** | **Initial Phase** | 初始相/其他相 (1 - Aust - Mart) |

> **注意**:
>
> 1. 训练时，模型输入通常为 $t$ 时刻的这 4 个通道，输出为 $t+1$ 时刻的预测。
> 2. 几何掩码 (Mask) 的形状为 `[Height, Width]`，在计算 Loss 时会自动广播。

---

## 5. 代码实现指南

我们将使用自定义的 `ParallelUFNO` 类（位于 `src/models/parallel_u_fno.py`）。

**模型调用示例**：

```python
import torch
from src.models.parallel_u_fno import ParallelUFNO

# 基础参数配置
n_modes = (16, 16)   # FNO 流：保留前16个低频分量
hidden_channels = 32 # 隐藏层宽度
in_channels = 3      # 输入通道：(x, y, T0)
out_channels = 2     # 输出通道：(T, Phase)

def get_model():
    model = ParallelUFNO(
        n_modes=n_modes,
        hidden_channels=hidden_channels,
        in_channels=in_channels,
        out_channels=out_channels
    )
    return model

# 测试维度
if __name__ == "__main__":
    model = get_model()
    # 模型接受 [B, C, H, W] 格式
    x = torch.randn(10, 3, 64, 64) 
    y = model(x) # 输出 [10, 2, 64, 64]
    print(y.shape)
    print(f"Output shape: {y.shape}") # 应为 [10, 2, 64, 64]
```

---

## 5. 常见问题与解决方案 (Troubleshooting)

在调试过程中，我们最可能遇到的问题是预测结果出现震荡，特别是相变场。

### 🔴 问题描述：吉布斯现象 (Gibbs Phenomenon)

我们的输出包含“马氏体相分数”，这是一个接近 0 或 1 的阶跃函数（突变）。
由于 FNO 基于傅里叶变换（正弦/余弦波叠加），用光滑的波去拟合陡峭的阶跃变化时，边缘会出现波纹状的震荡，这就是**吉布斯现象**。结果可能出现 -0.1 或 1.2 这种不符合物理意义的值。

### ✅ 解决方案

**方案 A：强制截断（推荐 Baseline 使用）**
不要修改模型核心架构，而是在模型输出后，或者在 Loss 计算前，对相变通道应用 `Sigmoid` 激活函数，或者直接 `clamp(0, 1)`。

```python
# 简单的物理约束
phase_pred = torch.clamp(model_output[:, 1, :, :], 0.0, 1.0)
```

**方案 B：增加高频信息**
增加 `n_modes` 参数（例如从 12 增加到 24）。这会允许模型使用更高频的波来拟合陡峭边缘，能减轻震荡，但会增加计算量和显存占用。

**方案 C：模型架构改进（文献备注）**
我们在调研中发现 *Bonneville et al. (2025)* 提出了 **`U-AFNO`** 架构。

* **原理**：将 U-Net 的跳跃连接（Skip Connections）与 FNO 结合。U-Net 擅长捕捉高频局部细节（边缘），FNO 擅长全局物理场。
* **决策**：鉴于我们项目的时间节点，**目前暂时不实现 U-AFNO**，仅将其作为“未来工作”写入报告。我们目前的重点是跑通标准 FNO 的 Baseline。

---

大家加油！遇到报错先查文档，解决不了的在群里发代码截图。🚀
