# 基于 FNO 的轴承钢感应淬火模拟 - 模型指导手册 (v1.0)

**文档位置**: `docs/model_guide.md`  
**最后更新**: 2025-12-10
**维护人**: 华浩宇

👋 大家好！

这是为了推进我们的“轴承钢感应淬火模拟”项目而编写的技术指南。为了确保大家在开发过程中步调一致，少走弯路，请务必仔细阅读以下内容。我们重点解决“为什么选 FNO”、“数据怎么存”以及“遇到震荡怎么调”这三个核心问题。

---

## 1. 项目背景与模型选择

在本次项目中，我们放弃了传统的有限元方法（FEM）和经典的卷积神经网络（CNN），转而选择 **Fourier Neural Operator (FNO)**。理由非常充分：

* **全局感受野 (Global Receptive Field)**：
    感应淬火涉及复杂的热传导过程。CNN 的卷积核是局部的，要捕捉全局的热扩散需要堆叠很多层。而 FNO 基于傅里叶变换，在频域操作，每一层都天然拥有全局视野，非常适合处理扩散方程。

* **分辨率无关性 (Resolution Invariant) [🔥核心优势]**：
    这是我们选择 FNO 的最大理由。
  * 传统的 CNN 如果在 64x64 的网格上训练，就只能预测 64x64 的结果。
  * **FNO 学习的是算子（Operator）而非具体的离散映射。** 这意味着我们可以为了节省时间在低分辨率（如 64x64）下训练模型，然后直接将其应用到高分辨率（如 256x256）的网格上进行预测，且保持较高的精度。

* **速度优势**：
    相比于商业软件（如 COMSOL/Abaqus）的迭代求解，训练好的 FNO 推理速度快几个数量级（毫秒级 vs 小时级），这对后续的工艺参数优化至关重要。

---

## 2. 核心原理（物理直觉版）

为了方便理解，请暂时忘掉“深度学习”的黑盒概念，用物理直觉来看 FNO：

1. **类比格林函数 (Green's Function)**：
    求解偏微分方程（PDE）时，如果我们找到了格林函数 $G(x, y)$，就可以通过积分 $\int G(x, y)f(y) dy$ 算出结果。FNO 本质上就是通过数据去**学习这个积分算子（Integral Operator）**。

2. **流程图解**：
    FNO 的核心计算发生在“频域”：
    * **Step 1: 空间域 -> 频域**：对输入（如初始温度场）做 FFT（快速傅里叶变换）。
    * **Step 2: 线性变换**：在频域中，偏微分操作往往变成了简单的乘法。网络在这里学习一个权重矩阵 $R$，只保留低频分量（主要的物理特征），过滤掉高频噪声。
    * **Step 3: 频域 -> 空间域**：做 IFFT（傅里叶逆变换）回到物理空间。
    * **Step 4: 非线性激活**：加上激活函数（如 GELU），拟合非线性关系。

> **一句话总结**：我们在频域里做低通滤波和特征提取，比在空间域硬算差分要高效得多。

---

## 3. 数据格式规范 (CRITICAL ⚠️)

> 由于数据还没有发下来，这里的内容先作为规范预览，后续会根据实际数据集进行微调。

为了避免每个人处理的数据 shape 不一样导致代码跑不通，**所有人必须严格遵守以下数据张量格式**。

我们在预处理和存储 `.npy` 或 `.pt` 文件时，统一使用 **Channel Last** 格式：

| 维度索引 | 维度名称 | 说明 | 示例值 |
| :--- | :--- | :--- | :--- |
| **Dim 0** | **Batch** | 实验/仿真样本的数量 | `N` (如 1000) |
| **Dim 1** | **X** | 空间网格 X 轴分辨率 | `S_x` (如 64) |
| **Dim 2** | **Y** | 空间网格 Y 轴分辨率 | `S_y` (如 64) |
| **Dim 3** | **Channels** | 物理量通道数 | `C` (输入/输出) |

### 举例说明

* **输入张量 (Inputs)**：Shape `[1000, 64, 64, 3]`
  * Channel 0: 网格 X 坐标
  * Channel 1: 网格 Y 坐标
  * Channel 2: 初始温度场 $T_0$
* **输出张量 (Outputs)**：Shape `[1000, 64, 64, 2]`
  * Channel 0: 最终温度场 $T$
  * Channel 1: 马氏体相分数 (Phase Fraction)

> **注意**：虽然 PyTorch 的 `Conv2d` 习惯用 `[B, C, X, Y]`，但在 FNO 的标准库实现中，通常输入处理习惯保留 `[B, X, Y, C]` 直到进入网络前再做 `permute`。为了统一数据清洗脚本，**存盘文件请务必保持上述表格格式**。

---

## 4. 代码实现指南

我们将使用 NVIDIA 官方维护或社区广泛使用的 `neuraloperator` 库（基于 PyTorch）。

**最简模型初始化 (Baseline)**：

这是一个标准的 2D FNO 模型定义，直接复制到你的代码中作为起点：

```python
import torch
from neuraloperator.models import FNO2d

# 基础参数配置
n_modes = (16, 16)  # 傅里叶模态数：保留前16个低频分量
hidden_channels = 32 # 隐藏层宽度
in_channels = 3      # 输入通道：(x, y, T0)
out_channels = 2     # 输出通道：(T, Phase)

def get_model():
    model = FNO2d(
        n_modes=n_modes,
        hidden_channels=hidden_channels,
        in_channels=in_channels,
        out_channels=out_channels
    )
    return model

# 测试维度
if __name__ == "__main__":
    model = get_model()
    # 注意：neuraloperator 内部通常会自动处理维度，
    # 但输入时建议确认 input shape 对应 [Batch, X, Y, Channels] 
    # 或根据库版本要求调整 permute
    x = torch.randn(10, 64, 64, 3) 
    x = x.permute(0, 3, 1, 2) # FNO2d通常接受 [B, C, X, Y]
    y = model(x)
    print(f"Output shape: {y.shape}") # 应为 [10, 2, 64, 64]
```

---

## 5. 常见问题与解决方案 (Troubleshooting)

在调试过程中，我们最可能遇到的问题是预测结果出现震荡，特别是相变场。

### 🔴 问题描述：吉布斯现象 (Gibbs Phenomenon)

我们的输出包含“马氏体相分数”，这是一个接近 0 或 1 的阶跃函数（突变）。
由于 FNO 基于傅里叶变换（正弦/余弦波叠加），用光滑的波去拟合陡峭的阶跃变化时，边缘会出现波纹状的震荡，这就是**吉布斯现象**。结果可能出现 -0.1 或 1.2 这种不符合物理意义的值。

### ✅ 解决方案

**方案 A：强制截断（推荐 Baseline 使用）**
不要修改模型核心架构，而是在模型输出后，或者在 Loss 计算前，对相变通道应用 `Sigmoid` 激活函数，或者直接 `clamp(0, 1)`。

```python
# 简单的物理约束
phase_pred = torch.clamp(model_output[:, 1, :, :], 0.0, 1.0)
```

**方案 B：增加高频信息**
增加 `n_modes` 参数（例如从 12 增加到 24）。这会允许模型使用更高频的波来拟合陡峭边缘，能减轻震荡，但会增加计算量和显存占用。

**方案 C：模型架构改进（文献备注）**
我们在调研中发现 *Bonneville et al. (2025)* 提出了 **`U-AFNO`** 架构。

* **原理**：将 U-Net 的跳跃连接（Skip Connections）与 FNO 结合。U-Net 擅长捕捉高频局部细节（边缘），FNO 擅长全局物理场。
* **决策**：鉴于我们项目的时间节点，**目前暂时不实现 U-AFNO**，仅将其作为“未来工作”写入报告。我们目前的重点是跑通标准 FNO 的 Baseline。

---

大家加油！遇到报错先查文档，解决不了的在群里发代码截图。🚀
